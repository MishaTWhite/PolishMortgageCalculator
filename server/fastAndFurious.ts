/**
 * Fast and Furious Test
 * 
 * Экстремально быстрый тест с минимальными операциями и ранним выходом
 * для гарантированного получения результата в пределах таймаута.
 */

import * as fs from 'fs';
import * as path from 'path';
import { chromium } from 'playwright';

// Константы
const LOG_DIR = './logs/fast_furious';
const COOKIES_FILE = './attached_assets/Pasted-1-Cookie-cooki-1745927642029.txt';
const TARGET_URL = 'https://www.otodom.pl/pl/oferty/sprzedaz/mieszkanie/warszawa/srodmiescie?roomsNumber=%5BTHREE%5D';
const MAX_RUNTIME = 20000; // Максимальное время выполнения в мс (20 секунд)

// Создаем директорию для логов
if (!fs.existsSync(LOG_DIR)) {
  fs.mkdirSync(LOG_DIR, { recursive: true });
}

// Функция для логирования
function log(message: string): void {
  console.log(message);
  fs.appendFileSync(path.join(LOG_DIR, 'log.txt'), message + '\n');
}

// Функция для сброса результатов и завершения процесса
function exitWithResults(results: any): void {
  fs.writeFileSync(
    path.join(LOG_DIR, 'results.json'), 
    JSON.stringify(results, null, 2)
  );
  
  log(`Final results saved to ${path.join(LOG_DIR, 'results.json')}`);
  log('=== TEST FINISHED ===');
  
  process.exit(0);
}

// Главная функция
async function fastAndFurious(): Promise<void> {
  log('=== STARTING FAST AND FURIOUS TEST ===');
  const startTime = Date.now();
  
  // Устанавливаем глобальный таймаут для завершения теста
  const timeoutId = setTimeout(() => {
    log('TIMEOUT REACHED! Saving partial results...');
    exitWithResults({
      status: 'timeout',
      message: 'Test did not complete within time limit',
      runtime: (Date.now() - startTime)
    });
  }, MAX_RUNTIME);
  
  try {
    // 1. Загружаем cookies и localStorage
    log('Loading session data...');
    const sessionData = JSON.parse(fs.readFileSync(COOKIES_FILE, 'utf-8'));
    const { cookies, localStorage } = sessionData;
    
    // 2. Запускаем браузер и создаем контекст
    log('Launching browser and context...');
    const browser = await chromium.launch({
      headless: true, 
      executablePath: '/nix/store/zi4f80l169xlmivz8vja8wlphq74qqk0-chromium-125.0.6422.141/bin/chromium',
      args: ['--no-sandbox', '--disable-dev-shm-usage']
    });
    
    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
      locale: 'pl-PL',
      timezoneId: 'Europe/Warsaw'
    });
    
    // 3. Устанавливаем cookies
    await context.addCookies(cookies);
    
    // 4. Создаем страницу и устанавливаем localStorage
    const page = await context.newPage();
    
    // Задаем localStorage до навигации
    await page.addInitScript(`() => {
      const storage = ${JSON.stringify(localStorage)};
      for (const [key, value] of Object.entries(storage)) {
        if (value) localStorage.setItem(key, value);
      }
    }`);
    
    // 5. Переходим по URL с сокращенным таймаутом
    log(`Navigating to ${TARGET_URL}...`);
    const response = await page.goto(TARGET_URL, {
      waitUntil: 'domcontentloaded',
      timeout: 10000 // Сокращаем таймаут загрузки страницы до 10 секунд
    });
    
    // 6. Получаем базовую информацию
    const status = response ? response.status() : 'unknown';
    const statusText = response ? response.statusText() : 'unknown';
    const title = await page.title();
    log(`Status: ${status} (${statusText})`);
    log(`Title: ${title}`);
    
    // 7. Сохраняем скриншот
    await page.screenshot({ path: path.join(LOG_DIR, 'screenshot.png') });
    
    // 8. Быстрая проверка на блокировку CloudFront
    const html = await page.content();
    const isBlocked = html.includes('ERROR: The request could not be satisfied') ||
                     html.includes('Generated by cloudfront');
    
    // 9. Быстрая проверка на наличие объявлений
    const articlesCount = await page.evaluate(() => {
      return document.querySelectorAll('article').length;
    });
    
    // 10. Закрываем ресурсы
    await page.close();
    await context.close();
    await browser.close();
    
    // 11. Формируем результаты
    const results = {
      status: 'success',
      url: TARGET_URL,
      responseStatus: status,
      responseStatusText: statusText,
      pageTitle: title,
      cloudFrontBlocked: isBlocked,
      articlesCount,
      runtime: (Date.now() - startTime),
      verdict: (!isBlocked && articlesCount > 0) 
        ? 'SUCCESS - Protection bypassed and listings found!'
        : (status === 200 && !isBlocked) 
          ? 'PARTIAL - Protection bypassed but no listings found'
          : 'FAILED - Could not bypass protection'
    };
    
    // 12. Выводим результаты
    log('\n=== TEST RESULTS ===');
    log(`Status code: ${status}`);
    log(`Page title: ${title}`);
    log(`CloudFront blocked: ${isBlocked}`);
    log(`Articles found: ${articlesCount}`);
    log(`Verdict: ${results.verdict}`);
    
    // Сохраняем результаты и завершаем тест
    exitWithResults(results);
    
  } catch (error) {
    log(`ERROR: ${error.message}`);
    
    // Сохраняем информацию об ошибке
    exitWithResults({
      status: 'error',
      message: error.message,
      stack: error.stack,
      runtime: (Date.now() - startTime)
    });
  } finally {
    clearTimeout(timeoutId);
  }
}

// Запускаем тест
fastAndFurious().catch(error => {
  log(`Unhandled error: ${error.message}`);
  process.exit(1);
});
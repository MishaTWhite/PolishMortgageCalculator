/**
 * Hybrid Extractor
 * 
 * Гибридный подход для извлечения данных о недвижимости:
 * 1. Быстрая загрузка страницы с Playwright + сессия
 * 2. Сохранение HTML
 * 3. Парсинг HTML с Cheerio для максимальной скорости
 */

import * as fs from 'fs';
import * as path from 'path';
import { chromium } from 'playwright';
import * as cheerio from 'cheerio';

// Константы
const MAX_RUNTIME = 30000; // 30 секунд максимум
const COOKIES_FILE = './attached_assets/Pasted-1-Cookie-cooki-1745927642029.txt';
const TARGET_URL = 'https://www.otodom.pl/pl/oferty/sprzedaz/mieszkanie/warszawa/srodmiescie?roomsNumber=%5BTHREE%5D';
const RESULTS_DIR = './scraper_results';
const LOG_DIR = './logs/hybrid_extractor';
const HTML_SAVE_PATH = path.join(LOG_DIR, 'extracted_page.html');

// Создаем необходимые директории
if (!fs.existsSync(RESULTS_DIR)) {
  fs.mkdirSync(RESULTS_DIR, { recursive: true });
}

if (!fs.existsSync(LOG_DIR)) {
  fs.mkdirSync(LOG_DIR, { recursive: true });
}

/**
 * Основная функция скрапера
 */
async function hybridExtract() {
  console.log('=== STARTING HYBRID EXTRACTOR ===');
  
  const startTime = Date.now();
  const timeoutId = setTimeout(() => {
    console.log('MAX RUNTIME REACHED! Exiting process...');
    process.exit(1);
  }, MAX_RUNTIME);
  
  let browser = null;
  let context = null;
  let page = null;
  let html = '';
  
  try {
    // ФАЗА 1: Загрузка страницы с Playwright
    console.log('PHASE 1: Loading page with Playwright...');
    
    // Загружаем данные сессии
    console.log('Loading cookies...');
    const sessionData = JSON.parse(fs.readFileSync(COOKIES_FILE, 'utf-8'));
    
    // Запускаем браузер с минимальными настройками
    console.log('Starting browser...');
    browser = await chromium.launch({
      headless: true,
      executablePath: '/nix/store/zi4f80l169xlmivz8vja8wlphq74qqk0-chromium-125.0.6422.141/bin/chromium',
      args: ['--no-sandbox', '--disable-dev-shm-usage']
    });
    
    // Создаем контекст и устанавливаем куки
    context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36'
    });
    await context.addCookies(sessionData.cookies);
    
    // Создаем страницу и переходим по URL
    page = await context.newPage();
    
    // Устанавливаем localStorage
    await page.addInitScript(`() => {
      const storage = ${JSON.stringify(sessionData.localStorage)};
      for (const [key, value] of Object.entries(storage)) {
        if (value) localStorage.setItem(key, value);
      }
    }`);
    
    // Переходим по URL
    console.log(`Navigating to ${TARGET_URL}...`);
    const response = await page.goto(TARGET_URL, {
      waitUntil: 'domcontentloaded',
      timeout: 15000
    });
    
    console.log(`Page loaded with status: ${response?.status()}`);
    const pageTitle = await page.title();
    console.log(`Page title: ${pageTitle}`);
    
    // Получаем HTML страницы
    html = await page.content();
    
    // Проверяем на CloudFront блокировку
    const isBlocked = html.includes('ERROR: The request could not be satisfied') || 
                      html.includes('Generated by cloudfront');
    
    if (isBlocked) {
      console.log('BLOCKED: CloudFront protection detected!');
      
      // Сохраняем информацию о блокировке
      const resultsFile = path.join(RESULTS_DIR, `hybrid_extractor_blocked_${Date.now()}.json`);
      fs.writeFileSync(resultsFile, JSON.stringify({
        status: 'blocked',
        url: TARGET_URL,
        timestamp: new Date().toISOString()
      }));
      
      console.log(`Results saved to: ${resultsFile}`);
      return;
    }
    
    // Сохраняем HTML для последующего анализа
    fs.writeFileSync(HTML_SAVE_PATH, html);
    console.log(`HTML saved to: ${HTML_SAVE_PATH}`);
    
    // Закрываем Playwright ресурсы как можно скорее
    await page.close();
    await context.close();
    await browser.close();
    page = null;
    context = null;
    browser = null;
    console.log('Playwright resources closed');
    
    // ФАЗА 2: Парсинг с Cheerio
    console.log('\nPHASE 2: Parsing with Cheerio...');
    const $ = cheerio.load(html);
    
    // Извлекаем информацию о количестве объявлений
    const countText = $('[data-cy="search.listing-panel.label"]').text().trim();
    const totalArticles = $('article').length;
    
    console.log(`Count text: ${countText}`);
    console.log(`Found ${totalArticles} article elements`);
    
    // Если объявлений нет, сохраняем инфо и выходим
    if (totalArticles === 0) {
      console.log('WARNING: No listings found on the page');
      
      const resultsFile = path.join(RESULTS_DIR, `hybrid_extractor_no_listings_${Date.now()}.json`);
      fs.writeFileSync(resultsFile, JSON.stringify({
        status: 'no_listings',
        timestamp: new Date().toISOString(),
        url: TARGET_URL,
        pageTitle,
        extractionTimeMs: Date.now() - startTime
      }));
      
      console.log(`Results saved to: ${resultsFile}`);
      return;
    }
    
    // Собираем данные из всех объявлений
    const listings = [];
    $('article').each((i, article) => {
      const $article = $(article);
      
      // Извлекаем данные с использованием основных селекторов Otodom
      // Если селектор данных изменится, мы используем запасные варианты
      const getTitle = () => {
        return $article.find('[data-cy="listing-item-title"]').text().trim() || 
              $article.find('h3').text().trim() ||
              $article.find('.css-1rhbnlm').text().trim() ||
              '';
      };
      
      const getPrice = () => {
        return $article.find('[data-cy="listing-item-price"]').text().trim() || 
              $article.find('.css-s8lxhp').text().trim() ||
              $article.find('span[data-testid]').text().trim() ||
              '';
      };
      
      const getArea = () => {
        return $article.find('[data-cy="listing-item-area"]').text().trim() || 
              $article.find('span[aria-label*="area"]').text().trim() ||
              $article.find('span[aria-label*="powierzchnia"]').text().trim() ||
              '';
      };
      
      const getAddress = () => {
        return $article.find('[data-cy="listing-item-address"]').text().trim() || 
              $article.find('p').text().trim() ||
              $article.find('.css-19fzh93').text().trim() ||
              '';
      };
      
      const getUrl = () => {
        return $article.find('a').attr('href') || '';
      };
      
      // Извлекаем данные
      const title = getTitle();
      const priceText = getPrice();
      const areaText = getArea();
      const address = getAddress();
      const url = getUrl();
      
      // Преобразуем текст в числа для расчетов
      const priceValue = parseInt(priceText.replace(/[^\d]/g, '')) || 0;
      const areaValue = parseFloat(areaText.replace(/[^\d,.]/g, '').replace(',', '.')) || 0;
      
      // Рассчитываем цену за квадратный метр
      let pricePerSqm = 0;
      let pricePerSqmText = '';
      if (priceValue > 0 && areaValue > 0) {
        pricePerSqm = Math.round(priceValue / areaValue);
        pricePerSqmText = `${pricePerSqm} zł/m²`;
      }
      
      // Добавляем объявление в массив только если есть заголовок и цена
      if (title && priceValue > 0) {
        listings.push({
          title,
          price: {
            text: priceText,
            value: priceValue
          },
          area: {
            text: areaText,
            value: areaValue
          },
          pricePerSqm: {
            text: pricePerSqmText,
            value: pricePerSqm
          },
          address,
          url
        });
      }
    });
    
    // Выводим информацию о найденных объявлениях
    console.log(`\n=== EXTRACTED LISTINGS ===`);
    console.log(`Total: ${listings.length} valid listings extracted`);
    
    // Показываем первое объявление в качестве примера
    if (listings.length > 0) {
      const example = listings[0];
      console.log('\nFirst listing example:');
      console.log(`Title: ${example.title}`);
      console.log(`Price: ${example.price.text} (${example.price.value})`);
      console.log(`Area: ${example.area.text} (${example.area.value})`);
      console.log(`Price per m²: ${example.pricePerSqm.text}`);
      console.log(`Address: ${example.address}`);
      console.log(`URL: ${example.url}`);
    }
    
    // Рассчитываем средние значения
    const prices = listings.map(item => item.price.value).filter(Boolean);
    const areas = listings.map(item => item.area.value).filter(Boolean);
    const pricesPerSqm = listings.map(item => item.pricePerSqm.value).filter(Boolean);
    
    const avgPrice = prices.length > 0 
      ? Math.round(prices.reduce((sum, p) => sum + p, 0) / prices.length) 
      : 0;
      
    const avgArea = areas.length > 0 
      ? Math.round(areas.reduce((sum, a) => sum + a, 0) / areas.length * 10) / 10 
      : 0;
      
    const avgPricePerSqm = pricesPerSqm.length > 0 
      ? Math.round(pricesPerSqm.reduce((sum, p) => sum + p, 0) / pricesPerSqm.length) 
      : 0;
    
    // Выводим статистику
    console.log('\n=== STATISTICS ===');
    console.log(`Average price: ${avgPrice} PLN`);
    console.log(`Average area: ${avgArea} m²`);
    console.log(`Average price per m²: ${avgPricePerSqm} PLN/m²`);
    
    // Сохраняем результаты
    const resultsFile = path.join(RESULTS_DIR, `hybrid_extractor_${Date.now()}.json`);
    fs.writeFileSync(resultsFile, JSON.stringify({
      status: 'success',
      timestamp: new Date().toISOString(),
      url: TARGET_URL,
      extractionTimeMs: Date.now() - startTime,
      totalArticles,
      countText,
      validListings: listings.length,
      listings,
      statistics: {
        avgPrice,
        avgArea,
        avgPricePerSqm
      }
    }, null, 2));
    
    console.log(`\nResults saved to: ${resultsFile}`);
    
  } catch (error) {
    console.error(`ERROR: ${error.message}`);
    
    // Сохраняем информацию об ошибке
    const errorFile = path.join(RESULTS_DIR, `hybrid_extractor_error_${Date.now()}.json`);
    fs.writeFileSync(errorFile, JSON.stringify({
      status: 'error',
      timestamp: new Date().toISOString(),
      url: TARGET_URL,
      error: error.message,
      stack: error.stack,
      extractionTimeMs: Date.now() - startTime
    }));
    
    console.log(`Error saved to: ${errorFile}`);
  } finally {
    // Закрываем оставшиеся ресурсы Playwright, если они существуют
    try {
      if (page) await page.close();
      if (context) await context.close();
      if (browser) await browser.close();
    } catch (err) {
      console.log('Error during cleanup:', err.message);
    }
    
    clearTimeout(timeoutId);
    const executionTime = Date.now() - startTime;
    console.log(`\nTotal execution time: ${executionTime}ms`);
    console.log('=== EXTRACTION COMPLETED ===');
  }
}

// Запускаем скрипт извлечения
hybridExtract()
  .then(() => setTimeout(() => process.exit(0), 500))
  .catch(err => {
    console.error('Unhandled error:', err);
    process.exit(1);
  });